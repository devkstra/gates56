import { createClient } from '@/lib/supabase/server'
import { NextResponse } from 'next/server'
import { revalidatePath } from 'next/cache'

// Helper to get the MIME type from base64
function getMimeType(base64: string): string {
  const mime = base64.match(/data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+).*,.*/);
  return mime ? mime[1] : 'image/jpeg';
}

export async function POST(request: Request) {
  try {
    const supabase = createClient()
    const body = await request.json()
    
    // First, upload the photo if it exists
    let photoUrl = ''
    
    if (body.photo_file) {
      console.log('Processing photo upload...')
      try {
        // Handle both data URL and raw base64
        const base64Data = body.photo_file.includes('base64,') 
          ? body.photo_file.split('base64,')[1] 
          : body.photo_file
        
        if (!base64Data) {
          console.error('No base64 data found in photo_file')
          throw new Error('Invalid photo data')
        }
        
        const mimeType = getMimeType(body.photo_file) || 'image/jpeg'
        const fileExt = mimeType.split('/')[1] || 'jpg'
        const fileName = `member-${Date.now()}.${fileExt}`
        const filePath = `member-photos/${fileName}`
        
        console.log(`Uploading photo: ${filePath} (${mimeType})`)
        
        // Convert base64 to buffer
        const buffer = Buffer.from(base64Data, 'base64')
        
        // Check if the bucket exists and is accessible
        const { data: buckets, error: bucketError } = await supabase.storage.listBuckets()
        if (bucketError) {
          console.error('Error listing buckets:', bucketError)
          throw new Error('Failed to access storage')
        }
        
        // Create the bucket if it doesn't exist
        if (!buckets.some((b: { name: string }) => b.name === 'member-photos')) {
          console.log('Creating member-photos bucket...')
          const { error: createBucketError } = await supabase.storage.createBucket('member-photos', {
            public: true,
            allowedMimeTypes: ['image/jpeg', 'image/png'],
            fileSizeLimit: 1024 * 1024 * 5 // 5MB
          })
          
          if (createBucketError) {
            console.error('Error creating bucket:', createBucketError)
            throw new Error('Failed to create storage bucket')
          }
          
          console.log('Successfully created member-photos bucket')
        }
        
        // Get the current session for the auth token
        const { data: { session }, error: sessionError } = await supabase.auth.getSession()
        
        if (sessionError || !session) {
          console.error('No active session:', sessionError?.message || 'No session found')
          throw new Error('Authentication required for file uploads')
        }
        
        // Upload to storage with explicit content type and auth token
        const { error: uploadError } = await supabase.storage
          .from('member-photos')
          .upload(filePath, buffer, {
            contentType: mimeType,
            upsert: false,
            cacheControl: '3600',
            // Pass the auth token in the options
            Authorization: `Bearer ${session.access_token}`
          })
          
        if (uploadError) {
          console.error('Error uploading photo:', uploadError)
          throw new Error(`Failed to upload photo: ${uploadError.message}`)
        }
        
        // Get public URL
        const { data: { publicUrl } } = await supabase.storage
          .from('member-photos')
          .getPublicUrl(filePath)
          
        if (!publicUrl) {
          throw new Error('Failed to get public URL for uploaded photo')
        }
        
        console.log('Photo uploaded successfully:', publicUrl)
        photoUrl = publicUrl
      } catch (uploadErr) {
        console.error('Error processing photo upload:', uploadErr)
        // Continue without photo if upload fails, but log the error
        console.log('Member will be created without a photo due to upload error')
      }
    }
    
    // Prepare member data for insertion - matching exact database column names
    const memberData = {
      name: body.name,
      email: body.email,
      phone: body.phone,
      age: body.age || 0,
      gender: body.gender,
      plan: body.plan,
      plan_start_date: body.plan_start_date,
      plan_end_date: body.plan_end_date,
      status: 'active',
      photo_url: photoUrl,
      join_date: new Date().toISOString(),
      last_visit_date: null
    }

    const { data, error } = await supabase
      .from('members')
      .insert([memberData])
      .select()
      .single()
      
    if (error) {
      console.error('Error inserting member:', error)
      return NextResponse.json(
        { error: error.message || 'Failed to create member' },
        { status: 400 }
      )
    }
    
    // Revalidate the dashboard page
    revalidatePath('/dashboard')
    
    // Map the response back to camelCase for the frontend
    return NextResponse.json({ 
      success: true, 
      data: {
        ...data,
        // Map snake_case to camelCase for the frontend
        planType: data.plan_type,
        planStartDate: data.plan_start_date,
        planEndDate: data.plan_end_date,
        photoUrl: data.photo_url,
        joinDate: data.join_date,
        lastVisitDate: data.last_visit_date
      }
    })
  } catch (error: unknown) {
    console.error('Registration error:', error)
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred'
    return NextResponse.json(
      { error: errorMessage },
      { status: 500 }
    )
  }
}
